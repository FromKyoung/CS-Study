## 배열
    동일한 데이터 타입의 요소들을 연속된 메모리 공간에 순차적으로 저장하는 선형 자료구조 


## 배열의 특징 
- 같은 데이터 타입만 저장 가능 -> `int` 타입으로 선언되면 정수 요소만 저장 가능 
- 생성 시 크기가 결정되고 이후 변경이 어려움
- 인덱스를 통해 접근하며 요소는 `0`부터 시작         

  <br>


## 선언 방법 (java) : 자료형 및 크기를 지정해야 함 
```java
// 1차원 배열
int[] arr1 = new int[5];
// 2차원 배열 
int[][] arr2 = new int[5][3];
```

  <br>


## 배열의 구조 
- 메모리 상에서 연속적으로 저장됨
- Element : 배열을 구성하는 각각의 데이터 
- Index : 배열의 각 요소 위치

    <br>

## 배열 사용의 장점 
- **인덱스**를 통해 빠르게 접근 가능 : 시간 복잡도 `O(1)`
- 연속된 메모리를 할당하기 때문에 **메모리 효율성**이 높음 


  <br>


## 배열 사용의 단점 
- 처음 설정한 크기를 변경하기 어려움 
- 동일한 데이터 타입 요소만 저장 가능함 
- 삽입과 삭제 시 뒤의 모든 요소의 인덱스를 조정해야 하므로 비효율적임 
- 고정된 크기를 가지므로 필요한 크기보다 큰 배열을 생성할 때 메모리가 낭비 될 수 있음 

  <br>

## 연산
- 접근(access)
- 검색(search)
- 추가(add)
- 제거(remove)

    <br>

## 시간복잡도 
| 연산     | 접근   | 탐색   | 삽입   | 삭제   |
|:------:|:----:|:----:|:----:|:----:|
| 시간 복잡도 | O(1) | O(n) | O(n) | O(n) |
              
  <br>

## :bulb: 배열 활용
- 데이터의 순차적 저장이 필요한 경우 사용
- 빠른 접근 시간이 요구되는 경우 사용
- 크기가 고정된 데이터 집합을 다루는 경우 사용 
- 2차원, 3차원의 다차원 데이터 구조가 필요한 경우 사용 
- 리스트, 테이블, 그래프 등의 데이터를 저장하고 관리할 때 사용
- 정렬, 탐색, 그래프 등 다양한 알고리즘을 구현할 때 사용
  <br>

---
  <br>

## 리스트 
    동적 메모리를 활용하여 데이터를 순서대로 저장하는 선형 자료구조   
  <br>

## 리스트의 특징 
- 데이터를 순서대로 저장하는 자료구조 
- 중복된 데이터 저장 가능
- 처음 요소와 마지막 요소가 구분됨 

  <br>

## 리스트의 종류 (구현 방식에 따른 분류)
1. 순차 리스트 (Array List)
> - **배열**을 기반으로 구현되는 리스트 
> - [장점] : 구현이 쉽고 인덱스를 이용한 임의 접근이 가능해 접근 속도가 빠름 
> - [단점] : 배열 기반이기 때문에 크기를 동적으로 조절하기 어려움 -> 크기 변경을 위해선 새로운 배열을 할당 해야 함 
2. 연결 리스트 (Linked List)
> - 메모리의 **동적 할당**을 통해 구현되는 리스트
> - 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성됨
> - 종류 : 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트 

  <br>

## 단순 연결 리스트 (Singly Linked List)
- 각 노드는 데이터 필드와 다른 노드를 가리키는 링크 필드로 구성됨
- 마지막 노드의 링크는 `Null` 값을 가짐
- 장점 : 노드 삽입과 삭제가 용이함
- 단점 : 임의 접근이 불가능하며, 처음부터 순차적으로 접근해야 함

  <br>

## 원형 연결 리스트 (Circular Linked List)
- 마지막 노드가 첫 번째 노드를 가리켜 원형으로 연결되는 구조
- 시작 노드가 특별히 필요하지 않고 순환 구조로 모든 노드에 접근 가능
- 삽입과 삭제가 용이 

  <br>

## 양방향 연결 리스트 (Doubly Linked List)
- 각 노드가 두 개의 포인터를 가지며, 하나는 이전 노드, 다른 하나는 다음 노드를 가리킴
- 양방향으로 노드를 순회할 수 있어 특정 노드의 삽입과 삭제가 빠름
- 포인터가 추가되어 메모리를 더 차지하고 코드가 복잡함

  <br>

## 선언 방법 (java) : `ArrayList`와 `LinkedList` 클래스 사용 
```java
import java.util.ArrayList;
import java.util.LinkedList;

public class ListExample {
    public static void main(String[] args) {
        // ArrayList 선언 및 초기화
        ArrayList<Integer> ex_ = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        // LinkedList 선언 및 초기화
        LinkedList<Integer> b = new LinkedList<>();
        b.add(1);
        b.add(2);
    }
}

```

  <br>


## 리스트의 구조 
- 여러 데이터 타입을 포함할 수 있음 
- 인덱스는 `0`부터 시작
- 대괄호 `[]`로 표현되고 요소들은 쉼표로 구분 

  <br>


## 리스트 사용의 장점 
- 데이터를 추가, 수정, 삭제할 때 유연하게 가능 
- 다양한 연산을 지원함 

  <br>


## 리스트 사용의 단점 
- 가변성으로 인해 불변성이 보장되지 않음
- 데이터 변경 시 메모리 사용량이 증가함
- 함수 인자로 전달 시 예기치 않은 변경이 발생할 수 있음 


  <br>


## 연산
- 접근(access)
- 검색(search)
- 추가(append)
- 제거(remove)

  <br>

## 시간복잡도 
| 연산     | 접근   | 삽입/삭제(끝) | 삽입/삭제(임의 위치) | 탐색   |
|:------:|:----:|:--------:|:------------:|:----:|
| 시간 복잡도 | O(1) | O(1)     | O(n)         | O(n) |

  <br>

## :bulb: 리스트 활용
- 데이터 저장 및 관리 
- 반복 잡업
- 데이터 변환 
- 다차원 데이터 표현 


  <br>

## 배열 vs 리스트 정리
| 특징     | 배열          | 리스트                |
|:------:|:-----------:|:------------------:|
| 메모리 구조 | 연속된 메모리     | 동적 메모리 할당          |
| 크기     | 고정 크기       | 가변 크기              |
| 접근 속도  | O(1)        | O(n)               |
| 삽입/삭제  | 비효율적 (O(n)) | 효율적 (O(1) 또는 O(n)) |

  <br>
