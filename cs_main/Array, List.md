## 배열 (Array)

```markdown
📌 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 순차적으로 저장하는 선형 자료구조이다. 
```

## 배열의 특징

```markdown
- 배열 선언할 때 크기를 지정하며 한 번 선언된 크기는 변경할 수 없다
- 배열 내 모든 요소는 같은 데이터 타입이어야 한다. 
- 인덱스 기반으로 접근에 원소에 접근할때는 O(1)의 시간 복잡도를 가진다.
```

## 배열의 연산

### **삽입 연산**

한칸씩 옆으로 이동할때 평균적으로 `n/2` 번 이동하게 되므로 `O(n)`의 시간 복잡도를 가진다.

```
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 40 50 60 70 80
=================================
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 90 40 50 60 70 80
                  -> -> -> -> ->

```

### **삭제 연산**

삭제도 마찬가지로 한칸씩 이동 해야하므로 `O(n)`의 시간 복잡도를 가진다.

```
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 40 50 60 70 80
=================================
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 50 60 70 80
              <- <- <- <-

```

## 배열의 시간복잡도

- 빠른 인덱스 접근으로 특정 요소에 접근하는 시간 → `O(1)`

```java
public class Example {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(arr[0]);
        // -> O(1)
    }
}
```

<br>

- 크기가 `n`인 배열의 모든 요소를 순차적으로 탐색하는 시간 → `O(n)`

```java
public class Example {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
            // -> 5번 반복. O(n)
        }
    }
}
```

- 요소 추가(배열의 빈 공간이 남아 있는 경우) → `O(1)`
- 요소 추가(배열의 빈 공간이 남아 있지 않은 경우) → `O(n)`
- 요소 삭제(배열 끝의 요소를 삭제 하는 경우) → `O(1)`
- 요소 삭제(배열 중간의 요소를 삭제하는 경우) → `O(n)`

<br>

## 📊 시간복잡도 표로 정리


| Operation | average case | worst case |
|:---------:|:------------:|:----------:|
| read      | O(1)         | O(1)       |
| insert    | O(n)         | O(n)       |
| delete    | O(n)         | O(n)       |
| search    | O(n)         | O(n)       |


<br>

## **배열의 활용**

```markdown
- 데이터의 순차적 저장이 필요한 경우 사용한다.
- 빠른 접근 시간이 요구되는 경우 사용한다.
- 정렬, 탐색, 그래프 등 다양한 알고리즘을 구현할 때 사용한다.
- 다차원 배열을 통해 행렬 또는 격자 형태의 데이터 구조를 표현할 때 사용한다. 
- 크기가 고정된 데이터 집합을 다루는 경우 사용한다.
```

---

## 리스트 (List)

```markdown
동적 메모리를 활용하여 데이터를 순서대로 저장하는 선형 자료구조이다.
```

## 리스트의 특징

```markdown
- 가변적인 크기를 가지며 다양한 데이터 타입의 요소들을 저장할 수 있는 동적 자료구조이다.
- 데이터는 논리적으로 순차적 구성이지만, 메모리상에서는 반드시 연속적으로 저장되지 않을 수 있다. 
- null 값을 가질 수 있다.
- 배열과 달리 포인터를 이용하므로 데이터의 삽입과 삭제가 용이하다.
```

## 리스트의 종류


1. 연결 리스트 (Linked List)
	- 단순 연결 리스트 (Singly Linked List)
	- 원형 연결 리스트 (Circular Linked List)
	- 양방향 연결 리스트 (Doubly Linked List)
2. 순차 리스트 (Array List)


## 연결 리스트 (Linked List) 특징

```markdown
- 동적 크기로 인해 메모리를 동적으로 할당하므로 크기가 고정되지 않는다.
- 데이터 요소들을 연결된 노드로 표현하는 자료구조로, 각 노드는 이전/다음 노드를 가리키는 포인터로 구성된다.
- 배열과 달리 데이터들을 옮길 필요가 없이 포인터만 수정하면 되므로 중간에 노드를 삽입하거나 삭제하는 작업이 빠르다. 
- 특정 인덱스에 접근하려면 순차적으로 탐색해야 하므로 배열보다 느리다.
```

<br>

## **LinkedList의 시간복잡도**

- 특정 요소 접근(처음 노드부터 순차적으로 탐색해야 한다.) → `O(n)`

```java
public class Example {
    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<>();
        list.add(1);
        list.add(2);
        list.add(3);

        System.out.println(list.get(2)); // -> O(n)
    }
}
```

- 순차 탐색 → `O(n)`

```java
public class Example {
    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<>();
        list.add(1);
        list.add(2);
        list.add(3);

        for (int num : list) {
            System.out.println(num); // -> O(n)
        }
    }
}
```

- 요소 추가(끝에 추가하는 경우) → `O(1)`
- 요소 추가(중간에 추가하는 경우, 삽입 위치를 찾기 위해 순차 탐색이 필요하다.) → `O(n)`
- 요소 삭제(끝에서 삭제하는 경우) → `O(1)`
- 요소 삭제(중간에서 삭제하는 경우) → `O(n)`

<br>

### **단순 연결 리스트 (Singly Linked List)**

- 각 노드는 데이터 필드와 다른 노드를 가리키는 링크 필드로 구성된다.
- 마지막 노드의 링크는 `Null` 값을 가진다.
- 노드 삽입과 삭제가 용이하다.
- 임의 접근이 불가능하며, 처음부터 순차적으로 접근해야 한다.

### **원형 연결 리스트 (Circular Linked List)**

- 마지막 노드가 첫 번째 노드를 가리켜 원형으로 연결되는 구조이다.
- 시작 노드가 특별히 필요하지 않고 순환 구조로 모든 노드에 접근 가능하다.
- 삽입과 삭제가 용이하다.

### **양방향 연결 리스트 (Doubly Linked List)**

- 각 노드가 두 개의 포인터를 가지며, 하나는 이전 노드, 다른 하나는 다음 노드를 가리킨다.
- 양방향으로 노드를 순회할 수 있어 특정 노드의 삽입과 삭제가 빠르다.
- 포인터가 추가되어 메모리를 더 차지하고 코드가 복잡하다.

<br>

## 순차 리스트 (Array List) 특징

```markdown
- 연속적으로 저장되기 때문에 인덱스를 통해 각 요소에 임의 접근(random access)이 가능하여 접근 속도가 빠르다. 
- 데이터 추가를 대비하여 여유 공간을 확보하므로 메모리 낭비가 발생할 수 있다. 
```

## **ArrayList의 시간복잡도**

- 빠른 인덱스 접근으로 인해 리스트의 특정 요소에 접근하는 시간 → `O(1)`

```java
public class Example {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1, 2, 3, 4, 5));
        System.out.println(list.get(0));
        // -> O(1)
    }
}
```

- 크기가 n인 리스트의 모든 요소를 순차적으로 탐색하는 시간 → `O(n)`

```java
public class Example {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1, 2, 3, 4, 5));
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
            // -> 5번 반복. O(n)
        }
    }
}
```

- 요소 추가(공간이 남아있는 경우, 배열 끝에 바로 추가한다.) → `O(1)`
- 요소 추가(공간이 부족한 경우, 내부 배열 확장 후 기존 요소를 복사한다.) → `O(n)`
- 요소 삭제(끝에서 삭제하는 경우) → `O(1)`
- 요소 삭제(중간에서 삭제하는 경우) → `O(n)`

## 📊 표로 정리

|         | Array                                | ArrayList                         | LinkedList                           |
|:-------:|:------------------------------------:|:---------------------------------:|:------------------------------------:|
| 구조      | 고정된 크기의 배열                           | 크기가 동적인 Array                     | 노드로 구성, 이중연결리스트                      |
| 크기 변경   | 불가능 (정적 할당)                          | 가변적, 크기 증가 시 기존 배열을 복사하는 비용 발생    | 가변적, 노드를 새로 생성하기만 하면 된다              |
| 메모리할당   | 연속된 메모리에 저장                          | 연속된 메모리에 저장                       | 비연속적, 포인터로 연결                        |
| 접근 속도   | 인덱스로 빠른 접근 가능 O(1)                   | 인덱스로 빠른 접근 가능 O(1)                | 요소 순차탐색으로 느림 O(n)                    |
| 삽입/삭제   | 느림 O(n)                              | 느림 O(n)                           | 빠름 O(1)                              |
| 메모리 효율성 | 배열에 데이터만 저장                          | 배열에 데이터만 저장                       | 각 노드가 다음 노드의 포인터를 저장하므로 더 많은 메모리 사용  |
| 언제 사용?  | 데이터크기가 고정적이고, 삽입/삭제보다는 빠른 접근이 중요한 경우 | 크기가 가변적이고, 삽입/삭제보다는 빠른 접근이 중요한 경우 | 크기가 가변적이고, 빠른 접근보다는 삽입/삭제가 빈번한 경우    |



