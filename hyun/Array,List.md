# Array

---

## 정의

→ 고정된 크기와 동일한 데이터 타입의 요소를 연속된 메모리 공간에 저장하는 데이터 구조

## 특징

- 고정된 크기를 가진다.
    - 배열은 생성 시  크기가 고정되며 크기를 변경하려면 새로운 배열을 생성해야한다.
        
        ex) `int arr[5]` 크기가 5인 배열 
        
        내부에 데이터를  다 사용하지 않아도 실제 크기는 5가 되며 배열의 크기를 크게 생성하고 적게 사용하면 메모리 낭비가 될 수 있다.
        
- 삽입과 삭제의 경우 O(n)의 시간 복잡도를 가진다.
- 인덱스 기반으로 접근에 원소에 접근할때는 O(1)의 시간 복잡도를 가진다.

### 삽입

```
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 40 50 60 70 80
=================================
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 90 40 50 60 70 80
                  -> -> -> -> ->
```

한칸씩 옆으로 옮겨줘야 하는데 평균적으로 총 n/2을 옮겨야함으로 O(n)의 시간 복잡도를 가진다.

### 삭제

```
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 40 50 60 70 80
=================================
index  0  1  2  3  4  5  6  7  8  9
data   10 20 30 50 60 70 80
              <- <- <- <-
```

삭제도 마찬가지로 한칸씩 땡겨야 하므로 O(n)의 시간 복잡도를 가진다.

## 사용 하는 경우

- 데이터의 값보다 순서가 중요할때 사용한다.
- 어떤 특정 요소를 빠르게 읽어야 할때 사용한다.
- 데이터의 크기가 자주 바뀌지않으며 삽입/삭제가 자주 일어나지 않을때 사용한다.

# List

---

## 정의

→ 순서가 의미를 갖는 데이터들의 집합

자료구조의 관점에서는 배열 또한 리스트에 포함되지만 프로그래밍 관점으로 리스트는 배열이 가지고 있는 인덱스의 장점을 버리고 빈틈없는 데이터의 적재라는 장점을 취한 인터페이스이다.

## 특징

- 배열과 달리 빈공간을 허락하지 않기때문에 메모리 낭비가 없다.
- 데이터들이 순차적으로 구성된 집합이지만, 데이터가 메모리상에는 연속적으로 있지않다.
- 요소를 삽입/삭제 할 수 있어 크기가 동적으로 변한다.
- 포인터를 사용하여 다음 데이터를 가리키고 있으므로 삽입/삭제에 용이하다.

### 삽입

```
next address [1000]   ->   [1020]   ->   [2010]   ->   [3050]   ->   [NULL]
data           0             1              2            3              4
=================================================================================
next address [1000]   ->   [1020]   ->   [1060]            [3050]   ->   [NULL]
data           0             1              2                3              4
                                             ->  [2010]  ->
                                                    7
```

2의 주소는 새롭게 저장된 7을 가르키는 1060주소로 바꿔주고  7은 다음 주소인 2010을 가르키도록 한다.

n번 +1번 으로 O(n)의 시간 복잡도를 가진다.

### 삭제

```
next address [1000]   ->   [1020]   ->   [2010]   ->   [3050]   ->   [NULL]
data           0             1              2            3              4
=================================================================================
next address [1000]   ->   [1020]   ->   [3050]          ->            [NULL]
data           0             1              2                            4
																											[3050]
																												3
```

2의 주소를 3이 가리키는 주소인 3050으로 바꿔준다.

n번 +1번 으로 O(n)의 시간 복잡도를 가진다.

## 사용 하는 경우

- 데이터 크기가 불확실하거나 가변적인 경우 사용한다.
- 삽입/삭제가 빠르기때문에 데이터의 삽입과 삭제가 빈번한 경우 사용한다.

# 자바에서..

# ArrayList

---

## 정의

→ List 인터페이스의 구현체 

```java
ArrayList<String> list = new ArrayList<>();

list.add("hello");
list.add("bye");

// 요소 출력
System.out.println(list); // [hello, bye]

// 특정 인덱스의 요소 가져오기 시간복잡도 O(1)
System.out.println(list.get(1)); // bye

// 요소 삭제
list.remove(0); // 인덱스 0의 요소 삭제
System.out.println(list); // [bye]
```

중복을 허용하고 순서를 유지하며 인덱스로 원소들을 관리한다. 배열은 크기가 지정되면 고정되지만 ArrayList는 클래스이기 때문에 배열을 추가, 삭제 할 수 있는 메소드들도 존재한다. (배열 기반)

일반 배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서 동일하지만 크기를 동적으로 늘릴 수 있다는 점에서 차이점이 있다.

## 특징

- ArrayList와 Vector 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장할 때 효율적이다.
- 데이터의 추가 삭제에 비교적 메모리가 많이 소모된다.

# LinkedList

---

## 정의

→ List 인터페이스의 구현체 

ArrayList의 단점인 데이터의 삽입 삭제의 시간복잡도 O(n) 의 단점을 보완하기 위해 만들어진 데이터구조이다/

노드 간에 연결(link)을 통해서 리스트로 구현된 객체이다. (연결리스트 기반)

## 특징

- 데이터를 추가삭제할때 공간을 늘려주거나 축소할 필요없이 노드의 next prev 값만 변경해주면 되기때문에 추가삭제에 용이하다
- 처음노드나 마지막노드의 next, prev 값을 따라가서 찾아야 하기때문에 특정 원소에 위치에 접근할때는 시간복잡도가 O(n) 이다.
- 위와 같은 이유로 수정에 대한 시간복잡도도 O(n) 이다.
