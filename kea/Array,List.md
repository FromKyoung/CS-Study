# Array

## Array(배열) 정의

<aside>
📌 배열은 프로그래밍에서 가장 기본적인 자료 구조 중 하나로, 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 구조

</aside>

### ✔️ **특징**

1. **고정된 크기**
    - 배열의 크기는 생성 시에 고정되면 이후 변경할 수 없다.
2. **연속된 메모리 공간**
    - 배열은 메모리 상에서 연속적으로 저장되어 있어 인덱스를 통해 빠르게 접근할 수 있다.
3. **인덱스(Index) 기반** 
    - 배열을 구성하는 각각의 값을 요소(element)라고 하며 배열에서의 위치를 가리키는 숫자는 인덱스(index)라고 한다.
    - 각 element는 순서에 따라 **고유한 인덱스**를 가진다.
    - 배열의 각 요소는 **0부터 시작하는 인덱스**로 접근한다.
4. **동일한 데이터 타입**
    - 배열 내 모든 요소는 같은 데이터 타입이어야 한다.

## Array 장점 및 단점

### **장점**

- 인덱스를 통해 각 요소에 접근이 가능하여 접근 속도가 빠르다.
- 구현이 쉽고 간단하다.
- 연속적인 메모리 할당으로 메모리를 효율적으로 사용할 수 있다.

### **단점**

- **크기가 고정적**이기 때문에 크기 변경 시 새로운 배열을 만들어 데이터를 옮겨야한다.
- 불필요한 메모리 사용으로 **메모리 낭비**가 발생할 수 있다.
- 배열 중간에 요소를 **삽입 및 삭제** 하려면 많은 요소들을 이동해야해서 **비효율적**이다.

## 시간 복잡도

| **Operation** | **average case** | **worst case** |
| --- | --- | --- |
| read | O(1) | O(1) |
| insert | O(n) | O(n) |
| delete | O(n) | O(n) |
| search | O(n) | O(n) |

→ (데이터가 정렬된 경우 이진 탐색으로 O(log n) 가능)

## 배열의 사용

- 고정된 크기의 데이터를 저장할 때 사용하기 좋은 자료구조이다.
- 삽입 및 삭제 작업은 적고 배열에 저장된 데이터를 검색하는 작업이 많을 때 사용하기 좋다.
- 정렬 및 탐색 알고리즘에서 기본 자료구조로 자주 사용한다.
- 다차원 배열을 통해 행렬 또는 격자 형태의 데이터 구조를 표현하는데 유용하다.

### 예제코드

### Java

```java
int arr[] = new int[10];

for(int i = 0; i < 10; i++) {
	arr[i] = i+1;
}

for(int i = 0; i < 10; i++) {
	System.out.print(arr[i]);
}
```

### Python

```java
arr = [1, 2, 3, 4, 5]

print(arr[2]

arr[2] = 10
print(arr[2])
```

### **배열의 확장**

배열의 크기를 동적으로 변경할 수 없기 때문에, 동적 배열 자료구조를 사용합니다:

- **Java**: `ArrayList` (내부적으로 크기를 동적으로 조절)
- **Python**: `list` (Python의 리스트는 기본적으로 동적 배열)

<br>

# List

## List(리스트) 정의

<aside>
💡 리스트는 Python에서 가장 기본적인 자료구조 중 하나로, 가변적인 크기를 가지며 다양한 데이터 타입의 요소들을 저장할 수 있는 동적 배열

</aside>

## 1. 배열 리스트(Array List)

<aside>
📌 동적 배열(Dynamic Array)라고 불리기도 하며 배열 기반으로 구현되어 데이터가 연속된 메모리 공간에 저장된다.

</aside>

## Array List의 장점 및 단점

### **장점**

- 연속적으로 저장되기 때문에 **인덱스를 통해 각 요소에 임의 접근(random access)**이 가능하여 접근 속도가 빠르다.
- 시간복잡도 : **O(1)**
- 메모리 상에서 연속된 공간에 저장되기 때문에 캐시 효율성이 높다.
- 내부적으로 크기를 자동으로 조정하여 추가 작업이 간단하다.

### **단점**

- 중간 위치에 삽입/삭제 시 나머지 요소를 이동해야 해서 **삽입/삭제가 비효율적이다.**
    - 시간복잡도 :  **O(n)**
- 데이터 추가를 대비하여 여유 공간을 확보하므로 메모리 낭비가 발생할 수 있다.
- 배열 리스트는 크기를 초과하면 새로운 배열을 생성하고 기존 데이터를 복사해야 해서 성능 저하가 발생할 수 있다.

## Array List의 사용

- 삽입/삭제가 드물고 주로 데이터를 검색하는 작업이 많을 때 사용하기 좋다.
- 연속적인 메모리 구조로 정렬 알고리즘 수행이 빨라 정렬작업이 필요한 경우 사용하기 좋다.
- 데이터가 순차적이고 인덱스를 통해 빠르게 접근할 때 사용하기 좋다.

## 2. 연결 리스트(Linked List)

<aside>
📌 데이터의 요소들이 메모리 상에서 연속적으로 저장되지 않고 각 요소가 다음 요소를 가리키는 포인터를 통해 연결된 형태를 가진다.

</aside>

## **✔️ 연결 리스트의 구조**

1. **노드(Node)**
    - 연결 리스트의 기본 단위로, **데이터(data)** 와 **다음 노드(next)** 의 포인터(주소)를 포함한다.
2. **헤드(Head)**
    - 연결 리스트의 시작점을 나타냅니다. 헤드는 첫 번째 노드의 주소를 저장한다.
3. **테일(Tail)**
    - 마지막 노드로, 다음 노드가 없는 노드이다. 일반적으로 `null`(Java) 또는 `None`(Python)으로 표시된다.

## **✔️ 연결 리스트의 특징**

1. 배열과 달리 크기가 고정되지 않으며, 동적으로 노드를 추가하거나 삭제할 수 있다.
2. **노드 기반 구조로** 각 노드는 메모리 상에서 연속적으로 저장되지 않아도 된다.
3. 배열에 비해 삽입과 삭제가 효율적이다. 
4. 특정 요소에 접근하려면 헤드부터 시작하여 순차적으로 탐색해야 하므로 접근 시간이 느리다. 

## **✔️ 연결 리스트의 종류**

### 1. **단일 연결 리스트 (Singly Linked List)**

- 각 노드가 다음 노드의 주소만 저장하는 가장 기본적인 연결 리스트.
- **특징**
    - 한 방향으로만 탐색 가능.
    - 삽입/삭제는 빠르지만, 특정 요소를 찾기 위해선 순차 탐색 필요.

### 2. **이중 연결 리스트 (Doubly Linked List)**

- 각 노드가 이전 노드(prev)와 다음 노드(next)의 주소를 저장.
- **특징**
    - 양방향 탐색 가능.
    - 삽입/삭제가 더 유연하지만, 메모리 사용량 증가.

### 3. **원형 연결 리스트 (Circular Linked List)**

- 마지막 노드가 첫 번째 노드를 참조하는 구조.
- **특징**
    - 리스트가 끝없이 순환 가능.
    - 대기열(Queue) 구현에 유용.

## **연결 리스트의 장점과 단점**

### **장점**

- 배열처럼 고정 크기 문제 없이 동적으로 크기를 조절할 수 있다.
- 배열과 달리 데이터들을 옮길 필요가 없이 포인터만 수정하면 되므로 중간에 노드를 삽입하거나 삭제하는 작업이 빠르다.
    - 중간 요소 삽입/삭제 시 시간 복잡도 : O(1)
- 배열처럼 크기를 미리 할당할 필요가 없어 메모리 사용이 효율적이다.

### **단점**

- 특정 인덱스에 접근하려면 순차적으로 탐색해야 하므로 배열보다 느리다.
    - 시간 복잡도 : O(n)
- 각 노드가 데이터와 함께 다음 노드의 주소를 저장해야 하므로 추가적인 메모리가 필요하다.
- 배열보다 구현이 복잡하며 포인터 조작 중 에러가 발생할 가능성이 있다.

## 연결 리스트의 사용

- 동적으로 크기를 조절해야 할때 유용하다.
- 데이터의 삽입/삭제가 빈번히 일어날 때 사용하기 좋다.
