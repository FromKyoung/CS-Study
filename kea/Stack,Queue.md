# Stack (스택)

<aside>
📌 
데이터를 하나씩 쌓아올린 형태의 자료구조로 가장 먼저 들어온 데이터가 가장 마지막에 나간다.
  
</aside>
<br>
<br>

- 스택(stack)의 사전적인 뜻 : 쌓아놓은 더미
- **후입선출 (LIFO : Last - In - First - Out)** : 가장 마지막에 들어온 데이터가 가장 먼저 나가는 구조
- 스택에서의 입출력은 맨 위에서만 일어난다.
- **top :** 스택의 맨 위에 있는 자료

```mathematica
|   C   | <- Top
|   B   |
|   A   |
+-------+
(LIFO: Last In, First Out)
```

## 기본 연산

- **Push**: 데이터를 스택의 맨 위에 추가
- **Pop**: 스택의 맨 위에서 데이터를 제거
- **Peek/Top**: 스택의 맨 위에 있는 데이터를 조회 (제거하지 않음)
- **isEmpty** - 스택이 비어있는지 확인
- **isFull** - 스택이 가득 차 있는지 확인

## **시간 복잡도 (Time complexity)**

| 연산 | 평균 | 최악 |
| --- | --- | --- |
| 접근 | `Θ(n)` | `O(n)` |
| 탐색 | `Θ(n)` | `O(n)` |
| 삽입 (push) | `Θ(1)` | `O(1)` |
| 삭제 (pop) | `Θ(1)` | `O(1)` |

→ 삽입 삭제는 항상 Top에서만 일어나기 때문에 push(), pop(), isEmpty(), peek() 모두 `O(1)` 시간이 걸린다.

## **구현 방식**

1. **배열(Array)** 기반 구현
    - 장점 : 구조가 간단하여 구현하기 쉽고 인덱스를 이용한 빠른 접근이 가능함.
    - 단점: 크기가 고정되어 있어 런타임시 필요에 따라 늘어나거나 줄어들지 않음.
2. **연결 리스트(Linked List)** 기반 구현
    - 장점 : 크기가 동적이기 때문에 런타임시 필요에 따라 크기가 확장 및 축소될 수 있음.
    - 단점 : 포인터 저장을 위한 추가 메모리 공간이 필요하여 메모리 사용량이 증가함.

## **사용 예시**

- 재귀 알고리즘 구현
- 웹 브라우저 방문 기록 혹은 뒤로가기 기능
- 후위(postfix) 표기법 연산
- 실행 취소 (undo)
- 문자열 역순 출력

<br>
<br>

# Queue (큐)

<aside>
📌
데이터를 줄 세운 터널 형태의 자료구조로 가장 먼저 들어온 데이터가 가장 먼저 나간다.

</aside>

<br>
<br>

- 큐(queue)의 사전적인 뜻 :(무엇을 기다리는 사람·자동차 등의) 줄
- **선입선출 (FIFO : First - In - First - Out) :** 먼저 들어온 데이터가 먼저 나가는 구조
- 입력은 뒤쪽에서만 일어나고 출력은 앞쪽에서만 일어난다.
- **rear(후단) :** 큐에서 삽입이 일어나는 뒤쪽 <br>
**front(전단) :** 큐에서 삭제가 일어나는 앞쪽

```mathematica
Front -> [A] [B] [C] <- Rear

(FIFO: First In, First Out)
```




## 기본 연산

- enqueue() - 큐에 끝(rear)에 항목을 추가
- dequeue() - 큐에 맨 앞(front)에 항목을 제거
- peek() - 큐에 맨 앞(front)에 있는 항목을 반환
- isfull() - 큐가 가득 찼는지 확인
- isempty() - 큐가 비어 있는지 확인

## **시간 복잡도 (Time complexity)**

| 연산 | 평균 | 최악 |
| --- | --- | --- |
| 접근 | `Θ(n)` | `O(n)` |
| 탐색 | `Θ(n)` | `O(n)` |
| 삽입 (enqueue) | `Θ(1)` | `O(1)` |
| 삭제 (dequeue) | `Θ(1)` | `O(1)` |

→ 큐의 앞/뒤에서 동작하기 때문에 데이터 추가/삭제에서 `O(1)` 시간이 걸린다.

## 구현 방식

1. **배열(Array)** 기반 구현 
    - 장점 : 구조가 간단하여 구현하기 쉽고 인덱스를 이용한 빠른 접근이 가능함.
    - 단점: 크기가 고정되어 있어 런타임시 필요에 따라 늘어나거나 줄어들지 않음.
2. **연결 리스트(Linked List)** 기반 구현
    - 장점 : 크기가 동적이기 때문에 런타임시 필요에 따라 크기가 확장 및 축소될 수 있음.
    - 단점 : 포인터 저장을 위한 추가 메모리 공간이 필요하여 메모리 사용량이 증가함.

## 사용 예시

- 우선 순위의 예약
- 프로세스 관리
- 은행 업무 ex)번호표
- 너비 우선 탐색 (BFS) 알고리즘

## 큐의 종류

1. **원형 큐(circular Queue)**

> 연속적인 배열로 구현된 큐에서 Front와 Rear가 배열의 끝에 도달하면 다시 처음으로 돌아가도록 구성된 큐
> 
- 특징
    - **FIFO**(First In, First Out) 구조 유지
    - 공간 낭비를 줄이고 배열 크기를 효율적으로 사용
    - 고정된 크기의 배열을 사용할 때 메모리 효율적
2. **우선순위 큐 (Priority Queue)**

> 데이터의 **우선순위**에 따라 먼저 처리될 데이터를 결정하는 큐
> 
- 특징
    - 높은 우선순위를 가진 데이터가 먼저 제거(Dequeue)됨
    - FIFO가 아닌 우선순위를 기준으로 처리
    - 힙(Heap) 자료구조를 기반으로 구현되는 경우가 많음
<br>
<br>

# **Stack vs Queue**

| 특성 | Stack | Queue |
| --- | --- | --- |
| **구조** | LIFO (Last In, First Out) | FIFO (First In, First Out) |
| 삽입 위치 | 스택의 맨 위 | 큐의 Rear (뒤쪽) |
| 삭제 위치 | 스택의 맨 위 | 큐의 Front (앞쪽) |
| 접근 가능성 | 맨 위 데이터만 접근 가능 | 맨 앞 데이터만 접근 가능 |
| **추가 연산** | Push, Pop, Peek | Enqueue, Dequeue, Peek |
| **시간 복잡도** | Push/Pop: O(1) | Enqueue/Dequeue: O(1) (최적 구현) |
| **주요 사용 예시** | 재귀 처리, 브라우저 뒤로가기, DFS | 프로세스 관리, 작업 대기열, BFS |

## **시각적 예시**

### **Stack (LIFO)**

| Push(1) → Push(2) → Push(3) → Pop |
| --- |
| [3] |
| [2] |
| [1] |

### **Queue (FIFO)**

| Enqueue(1) → Enqueue(2) → Enqueue(3) → Dequeue |
| --- |
| Front → [1] → [2] → [3] → Back |

