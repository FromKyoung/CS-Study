# 🌱 Array, List

<br>

|  | Array | ArrayList | LinkedList |
| --- | --- | --- | --- |
| **구조** | 고정된 크기의 배열 | 크기가 동적인 Array  | 노드로 구성, 이중연결리스트 |
| **크기 변경** | 불가능 (정적 할당) | 가변적, 크기 증가 시 기존 배열을 복사하는 비용 발생 | 가변적, 노드를 새로 생성하기만 하면 됨 |
| **메모리할당** | 연속된 메모리에 저장 | 연속된 메모리에 저장 | 비연속적, 포인터로 연결 |
| **접근 속도** | 인덱스로 빠른 접근 가능 O(1) | 인덱스로 빠른 접근 가능 O(1) | 요소 순차탐색으로 느림 O(n) |
| **삽입/삭제** | 느림 O(n) | 느림 O(n) | 빠름 O(1) |
| **메모리 효율성** | 배열에 데이터만 저장 | 배열에 데이터만 저장 | 각 노드가 다음 노드의 포인터를 저장하므로 더 많은 메모리 사용  |
| **언제 사용?** | 데이터크기가 고정적이고, 삽입/삭제보다는 빠른 접근이 중요한 경우 | 크기가 가변적이고, 삽입/삭제보다는 빠른 접근이 중요한 경우 | 크기가 가변적이고, 빠른 접근보다는 삽입/삭제가 빈번한 경우 |

<br>

### 📎

- **Array List의 크기 변경**
    배열이 가득 차게 되면 현재 크기보다 1.5배 큰 배열을 새로 생성하고 기존 배열을 새 배열에 복붙.
    [[참고이미지]](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b6f698e-8a67-4ad1-94b0-53ee956264c9/ec42cec0-6871-4f21-915c-6e41fbcdbd7f/image.png)
        
- **Array List의 삽입/삭제**
    기존크기를 초과하면 기존+기존*0.5로 늘어남. 새로운 배열에 복사하는 시간 발생 O(n)
    끝에 추가하는 경우는 O(1)
    
- **Linked List의 삽입/삭제** 
맨앞이나 맨 뒤에 삽입/삭제할 경우에만  O(1). 중간에 삽입/삭제하는 경우 그 위치까지 탐색하는 과정포함해야하므로 결국 O(n)이 됨. 그래도 array, array list보다는 빠름.

- **단일연결리스트와 이중연결리스트**
    단일: 데이터와 다음 노드의 포인터만 포함
    이중: 데이터와 이전,다음 노드의 포인터를 포함
    

<br><br>

## 🐳 정리

### **Array**

고정된 크기의 연속적인 메모리 공간에 같은 데이터타입의 데이터를 저장하는 자료구조

데이터에 인덱스를 통한 빠른 접근이 가능하지만, 삽입삭제는 느리다.

### **List**

크기가 동적으로 변할 수 있으며 메모리가 연속적이지 않은 자료구조. (일반적으로 ArrayList보다는 LinkedList를 의미)

### **ArrayList**

크기가 가변적인 배열로, Array와 List의 특징을 섞어 가지고 있다. 

인덱스를 통한 빠른 접근이 가능하지만, 삽입삭제는 느리다.

### **LinkedList**

데이터 요소들을 연결된 노드로 표현하는 자료구조로, 각 노드는 이전/다음 노드를 가리키는 포인터로 구성된다. 

삽입/삭제가 빠른 대신에 접근(조회)속도는 느리다.

<br><br>

---
### 참고 링크 

https://gwang920.github.io/datastructure/Array-ArrayList-LinkedList-%EB%B3%B5%EC%82%AC%EB%B3%B8/

https://inpa.tistory.com/entry/JCF-%F0%9F%A7%B1-ArrayList-vs-LinkedList-%ED%8A%B9%EC%A7%95-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90

https://mong9data.tistory.com/132

https://ongveloper.tistory.com/403
